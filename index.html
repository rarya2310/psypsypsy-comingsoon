<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSYPSYPSY - Coming Soon</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Import Google Fonts to match the video */
        @import url('https://fonts.googleapis.com/css2?family=Gochi+Hand&family=Poppins:wght@700&display=swap');

        /* * Basic setup 
         * Changed to flex-direction: column to stack the animation and links
         */
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            align-items: center;
            justify-content: center;
            background-color: #fffff0;
            color: #000000;
            overflow: hidden;
            /* Set a default font */
            font-family: 'Poppins', sans-serif;
        }

        /*
         * This container holds the text elements and has the SVG filter applied.
         * The filter is the key to the "gooey" effect.
         */
        #container {
            position: relative;
            /* Applying the SVG filter and a slight blur to smooth the effect */
            filter: url(#threshold) blur(0.2px);
            width: 100%;
            height: 9rem; /* Approx 144px, to fit largest font */
            text-align: center;
        }

        /* The SVG element itself should not be visible or take up space */
        #filters {
            position: absolute;
            height: 0;
            width: 0;
        }

        /*
         * Styling for the two text spans that will be morphed.
         * They are positioned absolutely on top of each other.
         * Their opacity and filter (blur) will be controlled by JavaScript.
         */
        #text1,
        #text2 {
            position: absolute;
            width: 100%;
            display: inline-block;
            left: 50%;
            transform: translateX(-50%);
            /* font-size: 60pt; /* Base font size - REMOVED for responsiveness */
            font-weight: 700;
            user-select: none; /* Prevents text selection */
            text-align: center;
        }

        /* --- STYLES FOR SOCIAL LINKS --- */

        /* Container for the social media links */
        #social-links {
            margin-top: 40px; /* Space above the links */
            display: flex;
            gap: 25px; /* Space between the links */
        }

        /* Styling for the individual links */
        #social-links a {
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            font-size: clamp(1rem, 2.5vw, 1.15rem); /* Responsive font size */
            color: #000000;
            text-decoration: none;
            display: flex; /* Allow icon and text to be on the same line */
            align-items: center; /* Vertically align icon and text */
            gap: 8px; /* Space between icon and text */
            transition: color 0.3s ease, transform 0.3s ease; /* Smooth transition for color and transform */
        }

        /* Hover effect for the links: subtle scale and color change */
        #social-links a:hover {
            color: #888888;
            transform: scale(1.05); /* Slightly enlarge on hover */
        }

        /* Animation for pulse effect */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Apply pulse animation on hover */
        #social-links a:hover .icon {
            animation: pulse 0.6s ease-in-out infinite; /* Apply pulse to icon on link hover */
        }

        /* Styling for the Font Awesome icons */
        #social-links .icon {
            font-size: clamp(1.2rem, 3vw, 1.5rem); /* Responsive icon size */
            display: inline-block; /* Ensure transform works correctly */
            transition: transform 0.3s ease; /* Smooth icon transform */
        }

        /* PNG social icons (match previous icon font size) */
        #social-links .social-icon {
            width: clamp(1.2rem, 3vw, 1.5rem);
            height: auto;
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.25rem;
        }

        /* Logo canvas styling â€” make larger than morphing text */
        #logo-canvas {
            /* Minimum larger than the largest morphing text (5.8rem) */
            max-width: clamp(10rem, 28vw, 520px);
            width: 100%;
            height: auto;
            display: block;
            margin: 0 0 2rem 0;
        }

    </style>
</head>
<body>

    <!-- Hidden source image and canvas for pixelation animation -->
    <canvas id="logo-canvas" role="img" aria-label="PSYPSYPSY logo"></canvas>
    <img id="original-logo" src="images/pixelated_white_logo.png" alt="Original logo" style="display:none">


    <!-- 
      This container will have the filter applied to it. All children
      of this element will be affected by the filter.
    --><div id="container">
        <!-- The two text elements that will morph between each other --><span id="text1"></span>
        <span id="text2"></span>
    </div>

    <!-- 
      NEW: Social media links container.
      This is placed outside the main text container.
    --><div id="social-links">
        <a href="https://www.instagram.com/psypyspsy_r1/" target="_blank" rel="noopener noreferrer">
            <img class="social-icon" src="images/insta_transparent_icon.png" alt="Instagram"> Instagram
        </a>
        <a href="https://www.reddit.com/r/psypsypsy/" target="_blank" rel="noopener noreferrer">
            <img class="social-icon" src="images/reddit-logo-icon.png" alt="Reddit"> Reddit
        </a>
    </div>

    <!-- 
      This SVG filter is the secret sauce. 
      The feColorMatrix dramatically increases the alpha contrast,
      making semi-transparent pixels (from the blur effect) either
      fully opaque or fully transparent. When the blurred text
      elements overlap, their semi-transparent areas merge and
      become a single solid, "gooey" shape.
    --><svg id="filters">
        <defs>
            <filter id="threshold">
                <feColorMatrix in="SourceGraphic" type="matrix"
                    values="1 0 0 0 0
                            0 1 0 0 0
                            0 0 1 0 0
                            0 0 0 255 -140" />
            </filter>
        </defs>
    </svg>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // --- DOM ELEMENTS ---
            const text1El = document.getElementById("text1");
            const text2El = document.getElementById("text2");

            // --- CONFIGURATION ---
            // Array of text objects, including the text itself and its specific font styles
            const texts = [
                // { text: "PSYPSYPSY", font: "'Gochi Hand', cursive", weight: "400", size: "clamp(3rem, 12vw, 5.8rem)" },
                { text: "It's a Vice.", font: "'Poppins', sans-serif", weight: "700", size: "clamp(2.5rem, 10vw, 5rem)" },
                { text: "MADE IN INDIA", font: "'Poppins', sans-serif", weight: "700", size: "clamp(2.5rem, 10vw, 5rem)" },
                { text: "Coming Soon", font: "'Poppins', sans-serif", weight: "700", size: "clamp(2.5rem, 10vw, 5rem)" },
            ];
            const morphTime = 1; // seconds for the morph transition
            const cooldownTime = 0.25; // seconds to wait after a transition

            // --- ANIMATION STATE VARIABLES ---
            let textIndex = texts.length - 1;
            let time = new Date();
            let morph = 0;
            let cooldown = cooldownTime;

            // --- HELPER FUNCTIONS ---

            // A helper to apply font styles from the text objects to an element
            function applyStyles(element, styles) {
                element.style.fontFamily = styles.font;
                element.style.fontWeight = styles.weight;
                element.style.fontSize = styles.size;
            }

            // Sets the blur and opacity of the two text elements
            function setMorph(fraction) {
                // Animate text2 (the incoming text)
                text2El.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
                text2El.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;

                // Animate text1 (the outgoing text)
                fraction = 1 - fraction;
                text1El.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
                text1El.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;
            }

            // Resets the styles during the cooldown period
            function doCooldown() {
                morph = 0;
                text2El.style.filter = "";
                text2El.style.opacity = "100%";
                text1El.style.filter = "";
                text1El.style.opacity = "0%";
            }

            // Calculates the morph progress and applies the styles
            function doMorph() {
                morph -= cooldown;
                cooldown = 0;
                let fraction = morph / morphTime;
                if (fraction > 1) {
                    cooldown = cooldownTime;
                    fraction = 1;
                }
                setMorph(fraction);
            }

            // --- MAIN ANIMATION LOOP ---
            function animate() {
                requestAnimationFrame(animate);

                const newTime = new Date();
                const shouldIncrementIndex = cooldown > 0;
                const dt = (newTime - time) / 1000;
                time = newTime;

                cooldown -= dt;

                if (cooldown <= 0) {
                    if (shouldIncrementIndex) {
                        // A new cycle is starting, so update the text content and styles
                        textIndex = (textIndex + 1) % texts.length;
                        const currentTextData = texts[textIndex % texts.length];
                        const nextTextData = texts[(textIndex + 1) % texts.length];

                        text1El.textContent = currentTextData.text;
                        applyStyles(text1El, currentTextData);

                        text2El.textContent = nextTextData.text;
                        applyStyles(text2El, nextTextData);
                    }
                    doMorph();
                } else {
                    doCooldown();
                }
            }

            // --- INITIALIZATION ---
            
            // Set the initial text content and styles before starting the animation
            const initialTextData = texts[textIndex % texts.length];
            const nextTextData = texts[(textIndex + 1) % texts.length];
            text1El.textContent = initialTextData.text;
            applyStyles(text1El, initialTextData);
            text2El.textContent = nextTextData.text;
            applyStyles(text2El, nextTextData);
            
            // Start the animation loop
            animate();
        });
    </script>
    <script>
        // Pixelation animation for the logo (uses an offscreen canvas for performance)
        (function(){
            const img = document.getElementById('original-logo');
            const canvas = document.getElementById('logo-canvas');
            if (!img || !canvas) return;
            const ctx = canvas.getContext('2d');

            // Parameters
            const minPixelation = 1;
            const maxPixelation = 48; // how blocky at max
            const loopDuration = 4000; // ms for full cycle (clear->pixelate->clear)

            const dpr = window.devicePixelRatio || 1;

            // Offscreen canvas to draw the tiny sampled image
            const off = document.createElement('canvas');
            const offCtx = off.getContext('2d');

            function resizeCanvas() {
                // Set internal pixel buffer to image natural size * dpr
                canvas.width = img.naturalWidth * dpr;
                canvas.height = img.naturalHeight * dpr;
                // CSS sizing controlled by CSS (max-width); ensure canvas displays at natural size
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                // Map drawing coordinates to CSS pixels
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }

            let start = null;

            img.addEventListener('load', () => {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                requestAnimationFrame(loop);
            });

            img.addEventListener('error', () => {
                console.error('Failed to load logo for pixelation:', img.src);
            });

            // If the image is already cached/loaded, start immediately
            if (img.complete && img.naturalWidth) {
                resizeCanvas();
                requestAnimationFrame(loop);
            }

            function loop(timestamp) {
                if (!start) start = timestamp;
                const elapsed = (timestamp - start) % loopDuration;
                const half = loopDuration / 2;

                // progress 0..1 for each half
                let progress;
                if (elapsed < half) {
                    progress = elapsed / half; // 0 -> 1
                    // clear -> pixelated
                    var current = minPixelation + (maxPixelation - minPixelation) * progress;
                } else {
                    progress = (elapsed - half) / half; // 0 -> 1
                    // pixelated -> clear
                    var current = maxPixelation - (maxPixelation - minPixelation) * progress;
                }

                const size = Math.max(1, Math.floor(current));

                // Compute CSS pixel dimensions (canvas internal / dpr)
                const cssW = canvas.width / dpr;
                const cssH = canvas.height / dpr;

                // Prepare offscreen canvas sized to the sampled (tiny) resolution
                const sampleW = Math.max(1, Math.floor(cssW / size));
                const sampleH = Math.max(1, Math.floor(cssH / size));
                off.width = sampleW;
                off.height = sampleH;

                // Draw downscaled image into the offscreen canvas
                offCtx.imageSmoothingEnabled = false;
                offCtx.clearRect(0, 0, sampleW, sampleH);
                offCtx.drawImage(img, 0, 0, sampleW, sampleH);

                // Draw the offscreen canvas scaled up to visible canvas
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, cssW, cssH);
                ctx.drawImage(off, 0, 0, sampleW, sampleH, 0, 0, cssW, cssH);

                requestAnimationFrame(loop);
            }
        })();
    </script>
</body>
</html>